<script>
const directions = {
  vLeading: 'vertical-leading',
  vTrailing: 'vertical-trailing',
  hLeading: 'horizontal-leading',
  hTrailing: 'horizontal-trailing',
};
export default {
  render(h) {
    // Grid cell renderer
    const getCell = ({ nodes, position, row, column }) => {
      // Get the default slot first
      if (nodes.length >= position) {
        return nodes[position - 1];
      }
      // Get the scoped slot second
      if (this.$scopedSlots.default) {
        return this.$scopedSlots.default({
          position,
          row,
          column,
        });
      }
      return null;
    };

    // Grid cells renderer
    const getCells = () => {
      const cells = [];
      // Resolve default slot nodes (remove whitespaced)
      const nodes =
        (this.$slots.default &&
          this.$slots.default.filter(n => n.tag !== undefined)) ||
        [];
      // Build cells
      for (let r = 1, p = 1; r <= this.rows; r++) {
        for (let c = 1; c <= this.columns; c++) {
          const rFromEnd = r - this.rows - 1;
          const cFromEnd = c - this.columns - 1;
          // Add the cell for current row & column
          cells.push(
            h(
              'div',
              {
                class: [
                  'vc-grid-cell',
                  `vc-grid-cell-row-${r}`,
                  `vc-grid-cell-row-${rFromEnd}`,
                  `vc-grid-cell-col-${c}`,
                  `vc-grid-cell-col-${cFromEnd}`,
                ],
                style: {
                  'grid-row': r,
                  'grid-column': c,
                },
                on: {
                  keydown: e =>
                    this.onCellKeydown({ row: r, column: c, event: e }),
                },
              },
              [getCell({ nodes, position: p++, row: r, column: c })],
            ),
          );
        }
      }
      return cells;
    };

    return h(
      'div',
      {
        class: 'vc-grid-container',
        style: this.containerStyle,
      },
      [...getCells()],
    );
  },
  props: {
    count: Number,
    rows: {
      type: Number,
      default: 1,
    },
    columns: {
      type: Number,
      default: 1,
    },
    gap: {
      type: String,
      default: '0px',
    },
    autofit: Boolean,
    columnWidth: {
      type: String,
      default: '1fr',
    },
    disableFocus: {
      type: Boolean,
      default: false,
    },
  },
  computed: {
    containerStyle() {
      return {
        gridTemplateColumns: this.gridTemplateColumns,
        gridGap: this.gap,
      };
    },
    gridTemplateColumns() {
      return `repeat(${this.autofit ? 'auto-fit' : this.columns}, ${
        this.columnWidth
      })`;
    },
  },
  methods: {
    onCellKeydown({ row, column, event }) {
      // Return if focus management is disabled
      if (this.disableFocus) return;
      const state = {
        row,
        column,
        alt: event.AltKey,
        target: this.$el,
        handled: false,
      };
      // Increment row/column based on key
      switch (event.key) {
        case 'ArrowUp': {
          this.scanFocusUp(state);
          break;
        }
        case 'ArrowDown': {
          this.scanFocusDown(state);
          break;
        }
        case 'ArrowLeft': {
          this.scanFocusLeft(state);
          break;
        }
        case 'ArrowRight': {
          this.scanFocusRight(state);
          break;
        }
        case 'Home': {
          state.column = 1;
          break;
        }
        case 'End': {
          state.column = this.columns;
          break;
        }
        case 'PageUp': {
          state.direction = directions.vLeading;
          break;
        }
        case 'PageDown': {
          state.direction = directions.vTrailing;
          break;
        }
        default: {
          return;
        }
      }
      // Emit rollover event if direction was assigned
      if (state.direction) {
        this.$emit('rollover', state);
      }

      if (!state.handled) {
        this.tryFocus(this.getCellEl(state));
        event.stopPropagation();
      }
      event.preventDefault();
    },
    tryFocus(parent = this.$el) {
      if (!parent) return false;
      const focusableEl = this.getFocusableEl(parent);
      if (focusableEl) {
        this.$nextTick(() => {
          focusableEl.focus();
        });
      }
      return !!focusableEl;
    },
    getCellFocusableEl({ row, column }) {
      this.getFocusableEl(this.getCellEl({ row, column }));
    },
    getCellEl({ row, column }) {
      const cellSelector = `.vc-grid-cell-row-${row}.vc-grid-cell-col-${column}`;
      return this.$el.querySelector(cellSelector);
    },
    getFocusableEl(parent = this.$el) {
      if (!parent) return null;
      const selectors = [
        '.vc-grid-focus',
        'button, [href], input, select, textarea, [tabindex="0"]',
        '[tabindex]:not([tabindex="undefined"])',
      ];
      return selectors.map(s => parent.querySelector(s)).find(el => el);
    },
    scanFocusUp(state) {
      state.row--;
      if (state.row < 1) {
        state.row = -1;
        state.direction = directions.vLeading;
      } else {
        state.focusableEl = this.getCellFocusableEl(state);
        if (!state.focusableEl) {
          this.scanFocusUp(state);
        }
      }
    },
    scanFocusDown(state) {
      state.row++;
      if (state.row > this.rows) {
        state.row = 1;
        state.direction = directions.vTrailing;
      } else {
        state.focusableEl = this.getCellFocusableEl(state);
        if (!state.focusableEl) {
          this.scanFocusDown(state);
        }
      }
    },
    scanFocusLeft(state) {
      state.column--;
      if (state.column < 1) {
        state.column = -1;
        state.direction = directions.hLeading;
      } else {
        state.focusableEl = this.getCellFocusableEl(state);
        if (!state.focusableEl) {
          this.scanFocusLeft(state);
        }
      }
    },
    scanFocusRight(state) {
      state.column++;
      if (state.column > this.columns) {
        state.columns = 1;
        state.direction = directions.hTrailing;
      } else {
        state.focusableEl = this.getCellFocusableEl(state);
        if (!state.focusableEl) {
          this.scanFocusRight(state);
        }
      }
    },
  },
};
</script>

<style lang="postcss" scoped>
.vc-grid-container {
  position: relative;
  flex-shrink: 1;
  display: grid;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}
.vc-grid-cell {
  display: flex;
  justify-content: center;
  align-items: center;
}
</style>
